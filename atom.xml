<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>靖諺的資訊學習筆記</title>
  
  
  <link href="https://www.tseng-school.com/atom.xml" rel="self"/>
  
  <link href="https://www.tseng-school.com/"/>
  <updated>2026-02-15T06:59:29.047Z</updated>
  <id>https://www.tseng-school.com/</id>
  
  <author>
    <name>chingyen06</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>APCS 2025/11 實作題題解 — C++</title>
    <link href="https://www.tseng-school.com/2026/02/11/apcs/apcs202511/"/>
    <id>https://www.tseng-school.com/2026/02/11/apcs/apcs202511/</id>
    <published>2026-02-11T06:10:45.000Z</published>
    <updated>2026-02-15T06:59:29.047Z</updated>
    
    <content type="html"><![CDATA[<div class="alert-block alert-info">💡 此筆記為APCS 2025年11月實作題考試的題目詳解。每一題的題解都包含解題思路、C++範例程式碼。</div><h2 id="第一題-字母配對-ZeroJudge-r626"><a href="#第一題-字母配對-ZeroJudge-r626" class="headerlink" title="第一題 字母配對 (ZeroJudge r626.)"></a>第一題 字母配對 (ZeroJudge r626.)</h2><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a><a href="https://zerojudge.tw/ShowProblem?problemid=r626">題目</a></h3><div class="alert-block alert-success">你有 $k$ 個堆疊，編號從 $1$ 到 $k$。每個堆疊中包含若干個物品。每個物品有兩個屬性：1. 一個大寫英文字母代表編號。2. 一個正整數代表分數。你可以執行任意次操作直到無法操作為止：<strong>操作：</strong>    1. 選擇兩個<strong>非空</strong>且<strong>不同</strong>的堆疊 $i$ 和 $j$（ $1 \le i, j \le k$ 且 $i \ne j$）。    2. 檢查堆疊 $i$ 和堆疊 $j$ <strong>頂部</strong>的物品。    3. 如果這兩個堆疊頂部物品的<strong>字母相同</strong>，則執行消除：        • 從堆疊 $i$ 和 $j$ 中移除頂部物品。        • 獲得的分數為這兩個被移除物品的<strong>分數總和</strong>。    4. 如果字母不同，則無法執行操作。目標是執行一系列操作，使得你最終獲得的<strong>總分數最大</strong>。</div><h3 id="輸入-輸出說明"><a href="#輸入-輸出說明" class="headerlink" title="輸入 &#x2F; 輸出說明"></a>輸入 &#x2F; 輸出說明</h3><table><thead><tr><th align="left"><strong>輸入說明</strong></th><th align="left"><strong>輸出說明</strong></th></tr></thead><tbody><tr><td align="left">第一行包含一個整數 $k$ ( $2 \le k \le 6$)，表示堆疊的數量。<br>接下來 $k$ 行，每行描述一個堆疊的內容。第 $i$ 行描述堆疊 $i$。<br>每行首先是一個整數 $n_i$，表示堆疊 $i$ 中物品的數量。<br>接著是 $n_i$ 對 (字母, 分數) 的描述，按照從堆頂到堆底的順序給出。<br>&emsp;• <code>字母</code> 是一個大寫英文字母 (‘A’ - ‘Z’)。<br>&emsp;• <code>分數</code> 是一個正整數 $s$ ( $1 \le s \le 10$ )。<br>保證每個堆疊最多 $12$ 個物品。<br>30 分: $k &#x3D; 3$<br>70 分: 無限制</td><td align="left">輸出一個正整數，代表能獲得的最大分數。</td></tr></tbody></table><h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><div class="alert-block alert-warning">這一題是 DFS 的題目，但如果要從 30 分到 100 分，就需要做記憶化搜尋。這題因為題目同時提到提到物品 (字母、分數) 與堆疊 (很多個物品)，所以大家可以發現到堆疊內有物品，物品內有字母、分數，所以我們可以使用物件導向 (OOP) 的封裝概念，別擔心，沒有很難看懂，下面有圖。如果不使用封裝來做，會有一堆變數散落，到時候會比較難看，debug 的時候會很痛苦。我將題目提到的物品用 struct 定義為 Item 物件，再把堆疊狀態用 struct 定義為 Content，結構如圖所示：<div style="display: flex; gap: 10px; margin: 10px 0;">  <img src="圖片1.png" alt="圖片1" style="width: 30%; border-radius: 4px; object-fit: contain;"></div><div style="display: flex; gap: 10px; margin: 10px 0;">  <img src="圖片2.png" alt="圖片2" style="width: 30%; border-radius: 4px; object-fit: contain;"></div>物品 Item 裡面放 `字母 w` 和 `分數 s`，堆疊狀態 Content 裡面包含 `物品數 n`、`堆疊 st` 和 `堆疊頂部位置 start`，其中 `堆疊 st` 用陣列存，陣列元素是 `物品 Item`。DFS 演算法：每個過程就是不斷嘗試。  1. 用雙層迴圈 i、j 任選兩個堆疊  2. 判斷是否頂部物品的字母相同，是就把他們用掉，start + 1  3. 呼叫 DFS 繼續遞迴，嘗試用掉這個組合後剩餘的組合  4. 遞迴回來後，判斷這個組合得到的分數 + 遞迴後得到的結果 (已經是最大值) 是否大於 Max，大於就把 Max 改成這個組合得到的分數 + 遞迴後得到的結果經過上述四步後，回傳 Max 作為這個狀態下繼續 DFS 的最大值。最後就會得到結果，但 k 太大就會超時。當我們每次在做 DFS 的時候，可能存在重複的組合，而上面的方法會重複做，太浪費時間。所以我們用一個 map<vector<int>, int> 存在這個狀態下，已經計算過的最大值。vector<int> 存 k 個堆疊各自剩餘的物品數量，代表一個狀態。再用 vector<int> 作為 map 的鑰匙 (key)，去存最大值，就直接用 map[這個 vector] = 最大值。那我們每次 DFS 開始前，就先檢查在目前狀態下，是否已經有計算過的最大值，有的話就直接回傳，達到記憶化搜尋的效果。<br><strong><註解></strong> 這題我示範的是用 map 做，並且使用 vector 作為鑰匙 (key) ，好處是很直觀，但可能會導致面臨效能瓶頸，你們可以直接使用 $13^6$ 大的一維陣列 memo，並將每個狀態，即 k 個堆疊分別剩餘的數量透過 13 進位編碼，這樣會快很多喔。假設 k = 6，這 6 個堆疊分別剩下 10、12、0、7、5、8 個物品，那你可以用 $10 \times 13^0 + 12 \times 13^1 + 0 \times 13^2 + 7 \times 13^3 + 5 \times 13^4 + 8 \times 13^5$ 表示這個狀態，把得出的答案當作索引存入最大值，即 memo[得出的答案] = 最大值，這樣會快很多。</div><h3 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line"><span class="type">char</span> w;</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Content</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">Item st[<span class="number">12</span>];  <span class="comment">// 由後往前可以當 stack 用 </span></span><br><span class="line"><span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Content content[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在一個向量 &#123;?, ?, ?, ?, ?, ?&#125; 的狀態下 (? 存剩餘的物品數)</span></span><br><span class="line"><span class="comment">// 繼續 DFS 的最大分數 </span></span><br><span class="line">map&lt;vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; mapp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j, temp, Max = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num1, num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從 30 分到 100 分</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state;  <span class="comment">// 目前狀態 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">state.<span class="built_in">push_back</span>(content[i].start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mapp.<span class="built_in">count</span>(state))  <span class="comment">// 已經試過了 </span></span><br><span class="line"><span class="keyword">return</span> mapp[state];  <span class="comment">// 直接回傳 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j=i<span class="number">+1</span>;j&lt;k;j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == j)  <span class="comment">// 同一個略過</span></span><br><span class="line"><span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">num1 = content[i].start;  <span class="comment">// 這一回合堆疊一頂部的物品的索引 </span></span><br><span class="line">num2 = content[j].start;  <span class="comment">// 這一回合堆疊二頂部的物品的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num1 &gt;= content[i].n || num2 &gt;= content[j].n)  <span class="comment">// 有任何地方取完了 </span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 頂部的物品的字母相同</span></span><br><span class="line"><span class="keyword">if</span> (content[i].st[num1].w == content[j].st[num2].w) &#123;</span><br><span class="line"><span class="comment">// 暫時的分數 = 這一回合獲得的分數(2個堆疊) + dfs其他選項的最大分數 </span></span><br><span class="line">temp = content[i].st[num1].s + content[j].st[num2].s;</span><br><span class="line">content[i].start++;  <span class="comment">// 用掉之後 </span></span><br><span class="line">content[j].start++;  <span class="comment">// 用掉之後</span></span><br><span class="line"></span><br><span class="line">temp += <span class="built_in">dfs</span>(k);  <span class="comment">// DFS 使用掉這個 i、j 後最大的可能 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &gt; Max)</span><br><span class="line">Max = temp;</span><br><span class="line"></span><br><span class="line">content[i].start--;  <span class="comment">// 還回去，不取 i 的其他可能 </span></span><br><span class="line">content[j].start--;  <span class="comment">// 還回去，不取 j 的其他可能</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從 30 分到 100 分</span></span><br><span class="line">mapp[state] = Max;  <span class="comment">// 存目前狀態下，繼續 DFS 的最大分數，表示之後不必再查 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">cin &gt;&gt; content[i].n;  <span class="comment">// n_i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;content[i].n;j++) &#123;</span><br><span class="line">cin &gt;&gt; content[i].st[j].w &gt;&gt; content[i].st[j].s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">dfs</span>(k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="運行結果"><a href="#運行結果" class="headerlink" title="運行結果"></a>運行結果</h3><p><font color="#00BB00"><strong>AC</strong></font> (31ms, 3.3MB)</p><h2 id="第二題-列印工廠-ZeroJudge-r627"><a href="#第二題-列印工廠-ZeroJudge-r627" class="headerlink" title="第二題 列印工廠 (ZeroJudge r627.)"></a>第二題 列印工廠 (ZeroJudge r627.)</h2><h3 id="題目-1"><a href="#題目-1" class="headerlink" title="題目"></a><a href="https://zerojudge.tw/ShowProblem?problemid=r627">題目</a></h3><div class="alert-block alert-success">你擁有一台印刷機，需要處理 $n$ 個印刷任務。每個印刷任務 $i$ 都有三個相關的參數：1. <strong>開始時間 (Start Time, $s_i$):</strong> 任務 $i$ 可以在 $s_i$ 或之後開始印刷。2. <strong>截止時間 (Deadline, $d_i$):</strong> 任務 $i$ 必須在 $d_i$ 或之前<strong>完成</strong>印刷。3. <strong>所需時間 (Processing Time, $t_i$):</strong> 任務 $i$ 需要 $t_i$ 秒的連續時間來完成印刷。印刷機在某一秒完成一個印刷品後，可以在<strong>下一秒開始</strong>時立即開始列印下一個印刷品。我們希望排定這 $n$ 個印刷任務的執行順序，使得所有任務都能在其截止時間內完成。然而若是讓印刷機空閒時間不足會減損印刷機的壽命，為了維護印刷機的壽命，我們希望最大化印刷機在能夠執行全部任務的前提下，<strong>任兩個任務的間隔時間</strong>最大值。<strong>任兩個任務的間隔時間</strong>定義為：在完成前一個印刷任務與開始下一個印刷任務之間，印刷機閒置的時間長度。你的任務是找出一個有效的任務排程順序，使得所有任務都能在截止時間內完成，並且印刷機在整個排程中獲得的總休息時間最大。</div><h3 id="輸入-輸出說明-1"><a href="#輸入-輸出說明-1" class="headerlink" title="輸入 &#x2F; 輸出說明"></a>輸入 &#x2F; 輸出說明</h3><table><thead><tr><th align="left"><strong>輸入說明</strong></th><th align="left"><strong>輸出說明</strong></th></tr></thead><tbody><tr><td align="left">第一行包含一個整數 $n$（ $2 \le n \le 8$ ），表示印刷任務的總數量。 接下來 $n$ 行，每行包含三個非負整數 $s_i, d_i, t_i$（ $0 \le s_i &lt; d_i \le 1000$ , $1 \le t_i \le d_i - s_i$ ），分別表示第 $i$ 個任務的開始時間、截止時間和所需時間。<br>30 分: $n \le 3$<br>70 分: 無限制</td><td align="left">如果存在一個有效的排程順序，使得所有任務都能在截止時間內完成，則輸出<strong>最大可能的總休息時間</strong>。保證測試資料一定可以存在一個排程方式完成所有任務。</td></tr></tbody></table><h3 id="解題思路-1"><a href="#解題思路-1" class="headerlink" title="解題思路"></a>解題思路</h3><div class="alert-block alert-warning">這一題是二分搜 + DFS 的題目。題目要求找<strong>最大可能的總休息時間</strong>，其實是在要我們求出任兩個任務之間最短的間隔時間的最大值 (ans)。那這種題目很明顯是需要用二分搜才不會超時，題目說 $0 \le s_i < d_i \le 1000$，所以我就把 left 設為 0、right 設為 1000，去搜尋出 ans 最大值。二分搜會需要一個條件決定接下來往大還是往小搜尋，而這個條件我們可以使用 DFS 去找在間隔時間 ans 下，是否能完成所有任務。DFS 演算法：1. 如果任務已經做完了就回傳 1，代表可以2. 透過 for 迴圈遍歷還沒做，且截止之前可以做完的任務now 代表可以開始印刷的時間。used[i] 確認是否做過了。max(s[i], now)：1. 如果 s[i] >= now 代表要等一段時間到 s[i] 才能開始，所以做完的時間是 s[i] + t[i]2. 如果 s[i] < now 代表可以直接開始做，所以做完的時間是 now + t[i]max(s[i], now) + t[i] <= d 就代表截止之前可以做完的任務3. 先做完這個任務，然後呼叫 DFS 繼續遞迴，嘗試剩餘的組合是否可以完成，可以就直接回傳 14. 不能做完就先不做這個任務，重新回到第二步找下一個可以先做的任務最後記得 DFS 演算法結束後，無論在間隔時間 ans 下，是否能完成所有任務，都要把 used 陣列重置。最後得到的 ans 就是答案。</div><h3 id="範例程式碼-1"><a href="#範例程式碼-1" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[<span class="number">8</span>], d[<span class="number">8</span>], t[<span class="number">8</span>], used[<span class="number">8</span>]=&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> relax, <span class="type">int</span> count)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, check = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count == n)  <span class="comment">// 任務已經都做完了 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 直接回傳 1 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span>(s[i], now) + t[i] &lt;= d[i] &amp;&amp; used[i] == <span class="number">0</span>) &#123;  <span class="comment">// 若截止之前可以做完 &amp; 沒做過 </span></span><br><span class="line">used[i] = <span class="number">1</span>;  <span class="comment">// 做這個任務  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="built_in">max</span>(s[i], now)+t[i]+relax, relax, count<span class="number">+1</span>) == <span class="number">1</span>)  <span class="comment">// DFS 做完這個任務後是否能完成的可能 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 已經做完了，直接回傳 1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 這個組合不行，換其他組合 </span></span><br><span class="line">used[i] = <span class="number">0</span>;  <span class="comment">// 不做這個任務 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">1000</span>, mid, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">cin &gt;&gt; s[i] &gt;&gt; d[i] &gt;&gt; t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cout &lt;&lt; mid &lt;&lt; &quot; | &quot; &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">0</span>, mid, <span class="number">0</span>) == <span class="number">1</span>) &#123;  <span class="comment">// 這個間隔時間可以 </span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;Yes: &quot; &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">ans = mid;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// 這個間隔時間不行 </span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;No: &quot; &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;  <span class="comment">//  重置使用紀錄 </span></span><br><span class="line">used[i] = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="運行結果-1"><a href="#運行結果-1" class="headerlink" title="運行結果"></a>運行結果</h3><p><font color="#00BB00"><strong>AC</strong></font> (1ms, 336KB)</p><h2 id="第三題-翻來覆去-ZeroJudge-r628"><a href="#第三題-翻來覆去-ZeroJudge-r628" class="headerlink" title="第三題 翻來覆去 (ZeroJudge r628.)"></a>第三題 翻來覆去 (ZeroJudge r628.)</h2><h3 id="題目-2"><a href="#題目-2" class="headerlink" title="題目"></a><a href="https://zerojudge.tw/ShowProblem?problemid=r628">題目</a></h3><div class="alert-block alert-success">給定一個長度為 $n$ 的排列（Permutation）$P=(p_1, p_2, ..., p_n)$，包含從 $1$ 到 $n$ 的所有整數。一開始，所有元素都按照它們在 $P$ 中的順序，從 $p_n$ 到 $p_1$ 依次被壓入 Stack $S_2$ 中（即 $p_n$ 在底，$p_1$ 在頂）。目標是要透過這兩個 stack 的 push 和 pop 操作來將這個排列做由小到大排序，並且輸出最少需要多少 pop 操作。以範例測資2 為例，目前的兩個 stack 為 [], [4, 2, 3, 1]<div style="display: flex; gap: 10px; margin: 10px 0;">  <img src="圖片3.png" alt="圖片3" style="width: 100%; border-radius: 4px; object-fit: contain;"></div>總共花費 8 次 pop 操作。</div><h3 id="輸入-輸出說明-2"><a href="#輸入-輸出說明-2" class="headerlink" title="輸入 &#x2F; 輸出說明"></a>輸入 &#x2F; 輸出說明</h3><table><thead><tr><th align="left"><strong>輸入說明</strong></th><th align="left"><strong>輸出說明</strong></th></tr></thead><tbody><tr><td align="left">第一行輸入一個正整數 $n$ ( $1 \le n \le 10^5$ )，接下來一行為 $1$ 到 $n$ 的一個排列。<br>30 分: $n \le 100$<br>70 分: 無限制</td><td align="left">輸出需要多少 pop 操作才能將這個排列由小到大排序好。</td></tr></tbody></table><h3 id="解題思路-2"><a href="#解題思路-2" class="headerlink" title="解題思路"></a>解題思路</h3><div class="alert-block alert-warning">這題我看解題報告都教 BIT，所以我來寫一下分而治之的方法，這題我用線段樹的方法做一次。因為線段樹只要滿足結合律就可以使用，也能使用 lazy propagation，比較萬用。這方面大家在大學的資料結構會學到。這一題是在問兩個 stack 互相 pop 與 push 後排序，輸出最少需要多少次 pop 操作。觀察一下可以發現其實 pop 次數就是算目前位置的索引到目標數字的索引間隔多少。線段樹的建立如下圖，以範例 2 為例：<div style="display: flex; gap: 10px; margin: 10px 0;">  <img src="圖片4.png" alt="圖片4" style="width: 50%; border-radius: 4px; object-fit: contain;"></div>我們稱根節點 (root)，就是最上面那個節點，他的範圍是 [1, n]，這裡是 [1, 4]，他的數量就是`左子節點 [1, 2] 的數量 2` + `右子節點 [3, 4] 的數量 2` = 4，自己不算 1 個數字喔，因為它只是存範圍內有幾個數字 (葉節點)，每一個內部節點 (撇除根節點跟葉節點的節點) 也都是如此計算數量。綠色的地方稱葉節點 (leaf)，它的特點是下面沒有任何節點，它的數量一定是 1，就他自己一個數字。<br>建立這個線段樹的方式就是 build 函式，主要就是用遞迴的方式從上而下建立。大家要注意因為我是把樹建立在陣列上，所以我 2 * node 代表是左子節點 (可自行驗算)、2 * node + 1 代表是右子節點 (可自行驗算)。<br>主程式輸出每個數字的時候，都會去找目前位置 now 與目標數字 target 的位置，把他當作一個區間 [now, target] 傳入 move 函式當 [left, right]，接著我們就看 [left, right] 是否把 每個節點的範圍 [start, end] 包住，不是的話繼續地回到完全包住，包住後就可以回傳數值，代表 [left, right] 的某一個子區間得到的數量。最後得到的數字加到 t 內，代表 pop 總數。<br>找到一個數字後，那個數字所在的位置就該清空，用 update 函式從上而下，把有關 target 的所有節點都減少 1。<br>最後輸出的 t 就是答案。<br><註解> 這方法比 BIT 慢，但是只需要具備結合律的特性就可以使用，即 $(a \times b) \time c = a \times (b \times c)$，所以除了區間加法，線段樹還能處理區間最大值 (Max)、最小值 (Min)、最大公因數 (GCD)等等問題。</div><h3 id="範例程式碼-2"><a href="#範例程式碼-2" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[<span class="number">100001</span>]=&#123;&#125;;</span><br><span class="line"><span class="type">int</span> p[<span class="number">100001</span>], pos[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start == end) &#123;  <span class="comment">// 代表在葉節點 (最後一排，底下沒節點) </span></span><br><span class="line">tree[node] = <span class="number">1</span>;  <span class="comment">// 自己一個數量就是 1 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * node, start, mid);  <span class="comment">// node 的左子節點 </span></span><br><span class="line"><span class="built_in">build</span>(<span class="number">2</span> * node + <span class="number">1</span>, mid + <span class="number">1</span>, end);  <span class="comment">// node 的右子節點</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 這個節點 node 的數量就是左右子的加總</span></span><br><span class="line"><span class="comment">// 自己不算，因為自己的數字存的是代表這區間有多少個葉節點 </span></span><br><span class="line">tree[node] = tree[<span class="number">2</span> * node] + tree[<span class="number">2</span> * node + <span class="number">1</span>]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">move</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這節點 node 代表的範圍 [start, end] 不在 [left, right] 內 </span></span><br><span class="line"><span class="keyword">if</span> (right &lt; start || end &lt; left)  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這節點 node 代表的範圍 [start, end] 在 [left, right] 內 </span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; end &lt;= right)</span><br><span class="line"><span class="keyword">return</span> tree[node];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這節點 node 代表的範圍 [start, end] 不完全在 [left, right] 內 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">move</span>(<span class="number">2</span> * node, start, mid, left, right) + <span class="built_in">move</span>(<span class="number">2</span> * node + <span class="number">1</span>, mid + <span class="number">1</span>, end, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start == end) &#123;  <span class="comment">// 數字拿走了 </span></span><br><span class="line">tree[node] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)  <span class="comment">// 要輸出的數字 &lt;= mid 代表在左子節點範圍內 </span></span><br><span class="line"><span class="built_in">update</span>(<span class="number">2</span> * node, start, mid, target);</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 反之在右子節點範圍內 </span></span><br><span class="line"><span class="built_in">update</span>(<span class="number">2</span> * node + <span class="number">1</span>, mid + <span class="number">1</span>, end, target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把更新後的結果更新到這個節點</span></span><br><span class="line"><span class="comment">// 這個節點 node 的數量就是左右子的加總 </span></span><br><span class="line">    tree[node] = tree[<span class="number">2</span> * node] + tree[<span class="number">2</span> * node + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, n, now, target;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> t = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> left, right;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">cin &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">pos[p[i]] = i;  <span class="comment">// 存每個數字的索引 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);  <span class="comment">// 建立線段樹</span></span><br><span class="line"></span><br><span class="line">now = <span class="number">1</span>;  <span class="comment">// 一開始位置設在 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">target = pos[i];  <span class="comment">// 查詢現在要輸出的數字的位置</span></span><br><span class="line"></span><br><span class="line">left = <span class="built_in">min</span>(now, target);  <span class="comment">// 小的當左界</span></span><br><span class="line">right = <span class="built_in">max</span>(now, target);  <span class="comment">// 大的當右界 </span></span><br><span class="line"></span><br><span class="line">t += <span class="built_in">move</span>(<span class="number">1</span>, <span class="number">1</span>, n, left, right);  <span class="comment">// 算這次輸出數字移動需要的 pop 數 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, target);  <span class="comment">// 更新取走要輸出的數字後的線段樹 </span></span><br><span class="line"></span><br><span class="line">now = target;  <span class="comment">// 移動位置 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="運行結果-2"><a href="#運行結果-2" class="headerlink" title="運行結果"></a>運行結果</h3><p><font color="#00BB00"><strong>AC</strong></font> (20ms, 2.1MB)</p><div class="alert-block alert-danger"><strong>查看更多資訊請至：</strong><a href="https://www.tseng-school.com/">https://www.tseng-school.com/</a> </div>]]></content>
    
    
    <summary type="html">此筆記為APCS 2025年11月實作題考試的題目詳解。每一題的題解都包含解題思路、C++範例程式碼。</summary>
    
    
    
    <category term="APCS" scheme="https://www.tseng-school.com/categories/APCS/"/>
    
    
    <category term="C++" scheme="https://www.tseng-school.com/tags/C/"/>
    
    <category term="APCS" scheme="https://www.tseng-school.com/tags/APCS/"/>
    
    <category term="ZeroJudge" scheme="https://www.tseng-school.com/tags/ZeroJudge/"/>
    
  </entry>
  
  <entry>
    <title>APCS 2025/10 實作題題解 — C++</title>
    <link href="https://www.tseng-school.com/2026/02/09/apcs/apcs202510/"/>
    <id>https://www.tseng-school.com/2026/02/09/apcs/apcs202510/</id>
    <published>2026-02-09T07:15:00.000Z</published>
    <updated>2026-02-13T09:49:45.753Z</updated>
    
    <content type="html"><![CDATA[<div class="alert-block alert-info">💡 此筆記為APCS 2025年10月實作題考試的題目詳解。每一題的題解都包含解題思路、C++範例程式碼。</div><h2 id="第一題-彗星撞擊-ZeroJudge-r488"><a href="#第一題-彗星撞擊-ZeroJudge-r488" class="headerlink" title="第一題 彗星撞擊 (ZeroJudge r488.)"></a>第一題 彗星撞擊 (ZeroJudge r488.)</h2><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a><a href="https://zerojudge.tw/ShowProblem?problemid=r488">題目</a></h3><div class="alert-block alert-success">你正在研究一個長 $R$ 寬 $C$ 的矩形區域，模擬恐龍棲息地與彗星撞擊事件。初始地圖是 $R \times C$ 的網格（座標從 $0$ 開始編號，行座標範圍 $[0, R-1]$，列座標範圍 $[0, C-1]$），所有區域的<strong>初始地面高度均為 $D$</strong>。地圖上有 $K$ 隻<strong>清醒</strong>的恐龍，<strong>相同座標可能有多隻恐龍。</strong>接著，地圖將經歷 $M$ 次彗星撞擊事件。每次撞擊由<strong>中心點 $(a, b)$</strong>、<strong>撞擊邊長 $S$</strong> 和<strong>撞擊深度 $d$</strong> 定義。<strong>撞擊規則：</strong>1. <strong>影響範圍：</strong> 每次撞擊的影響範圍是以 $(a, b)$ 為中心的邊長 $S$ 正方形區域（需與地圖邊界取交集）。2. <strong>暈眩與凹陷判定：</strong>• 如果在撞擊的影響範圍內<strong>存在至少一隻清醒的恐龍</strong>：◦ 範圍內所有清醒恐龍會變為<strong>暈眩</strong>狀態。◦ 本次撞擊不會對該範圍造成地面凹陷。• 否則（影響範圍內沒有清醒恐龍）：◦ 影響範圍內所有區域的地面高度會<strong>減少 $d$</strong>。地面高度可以為負數。請計算經歷 $M$ 次撞擊後：1. 地圖上最高的地面高度。2. 地圖上最低的地面高度。3. 保持清醒的恐龍區域數量。</div><h3 id="輸入-輸出說明"><a href="#輸入-輸出說明" class="headerlink" title="輸入 &#x2F; 輸出說明"></a>輸入 &#x2F; 輸出說明</h3><table><thead><tr><th align="left"><strong>輸入說明</strong></th><th align="left"><strong>輸出說明</strong></th></tr></thead><tbody><tr><td align="left">第一行包含三個整數 $R, C, D$。($1 \le R, C, D \le 100$)<br>第二行包含一個整數 $K$。($0 \le K \le 100$)<br>接下來 $K$ 行，每行包含兩個整數 $r_i, c_i$，代表恐龍的初始座標。($0 \le r_i \le R, 0 \le c_i \le C$)<br>接下來一行包含一個整數 $M$。($0 \le M \le 100$)<br>接下來 $M$ 行，每行包含四個整數 $a_j, b_j, S_j, d_j$，代表第 $j$ 次撞擊的參數。<br>($0 \le a_j &lt; R, 0 \le b_j &lt; C, 1 \le S_j \le 19$ 且為奇數 $,1 \le d_j \le 10$)<br>(60 分): $R &#x3D; 1$<br>(40 分): 無限制</td><td align="left">輸出僅一行，包含三個整數，以空格分隔：<strong>最高地面高度 最低地面高度 清醒恐龍數量</strong></td></tr></tbody></table><h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><div class="alert-block alert-warning">這題有點考驗耐心，慢慢看題目。我用 mapp 陣列存地形高度、dinosaur 陣列存清醒的恐龍數。要注意的是題目給 (a, b) 這樣的寫法，陣列要寫 mapp[b][a]，因為 a 是 x 座標，屬於 mapp 的行 (column)；b 是 y 座標，屬於 mapp 的列 (row)。因為題目說 $s_j$ 是奇數，而且 C++ 如果用 s / 2 就會是無條件捨去，所以找出彗星撞擊的範圍就只需要找 $(a - s/2, b - s/2)$ 到 $(a + s/2, b + s/2)$ 的範圍內有沒有清醒的恐龍。找出清醒的恐龍數後，如果沒有清醒的恐龍，就將 $(a - s/2, b - s/2)$ 到 $(a + s/2, b + s/2)$ 範圍內的高度減掉 $d_j$。最後再用迴圈找出剩餘的恐龍數與最高與最低的地面高度就可以了。</div><h3 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j, k, l;</span><br><span class="line"><span class="type">int</span> R, C, D, K, M, r, c;</span><br><span class="line"><span class="type">int</span> a, b, s, d;</span><br><span class="line"><span class="type">int</span> t, Max, Min;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; R &gt;&gt; C &gt;&gt; D &gt;&gt; K;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mapp[C][R]=&#123;&#125;, dinosaur[C][R]=&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;C;i++) &#123;  <span class="comment">// 初始高度設為 D </span></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;R;j++) &#123;</span><br><span class="line">mapp[i][j] = D;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;K;i++) &#123;</span><br><span class="line">cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">dinosaur[c][r]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;M;j++) &#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; s &gt;&gt; d;</span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span>;  <span class="comment">// 範圍內是否有清醒的恐龍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;k: &quot; &lt;&lt; b-s/2 &lt;&lt; &quot;~&quot; &lt;&lt; b+s/2 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;l: &quot; &lt;&lt; a-s/2 &lt;&lt; &quot;~&quot; &lt;&lt; a+s/2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (k=b-s/<span class="number">2</span>;k&lt;=b+s/<span class="number">2</span>;k++) &#123;  <span class="comment">// 列的範圍 (y 座標) </span></span><br><span class="line"><span class="keyword">for</span> (l=a-s/<span class="number">2</span>;l&lt;=a+s/<span class="number">2</span>;l++) &#123;  <span class="comment">// 行的範圍 (x 座標) </span></span><br><span class="line"><span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt;= C || l &lt; <span class="number">0</span> || l &gt;= R)  <span class="comment">//超出邊界 </span></span><br><span class="line"><span class="keyword">continue</span>;  <span class="comment">// 略過</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dinosaur[k][l] &gt; <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; | &quot; &lt;&lt; dinosaur[k][l] &lt;&lt; endl;</span></span><br><span class="line">t++;</span><br><span class="line">dinosaur[k][l] = <span class="number">0</span>;  <span class="comment">// 砸暈所有恐龍 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">0</span>) &#123;  <span class="comment">// 沒有清醒的恐龍 </span></span><br><span class="line"><span class="keyword">for</span> (k=b-s/<span class="number">2</span>;k&lt;=b+s/<span class="number">2</span>;k++) &#123;  <span class="comment">// 列的範圍 (y 座標) </span></span><br><span class="line"><span class="keyword">for</span> (l=a-s/<span class="number">2</span>;l&lt;=a+s/<span class="number">2</span>;l++) &#123;  <span class="comment">// 行的範圍 (x 座標) </span></span><br><span class="line"><span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt;= C || l &lt; <span class="number">0</span> || l &gt;= R)  <span class="comment">//超出邊界 </span></span><br><span class="line"><span class="keyword">continue</span>;  <span class="comment">// 略過</span></span><br><span class="line"></span><br><span class="line">mapp[k][l] = mapp[k][l] - d;  <span class="comment">// 地面高度下降 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span>;  <span class="comment">// 存剩餘的清醒恐龍數 </span></span><br><span class="line">Max = mapp[<span class="number">0</span>][<span class="number">0</span>];  <span class="comment">// 存最高的地面高度</span></span><br><span class="line">Min = mapp[<span class="number">0</span>][<span class="number">0</span>];  <span class="comment">// 存最低的地面高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;C;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;R;j++) &#123;</span><br><span class="line">t += dinosaur[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mapp[i][j] &gt; Max)  <span class="comment">// 取較大的當最高的地面高度</span></span><br><span class="line">Max = mapp[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mapp[i][j] &lt; Min)  <span class="comment">// 取較小的當最低的地面高度</span></span><br><span class="line">Min = mapp[i][j];</span><br><span class="line"></span><br><span class="line"><span class="comment">// cout &lt;&lt; mapp[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; Max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Min &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="運行結果"><a href="#運行結果" class="headerlink" title="運行結果"></a>運行結果</h3><p><font color="#00BB00"><strong>AC</strong></font> (1ms, 396KB)</p><h2 id="第二題-航空拍照圖-ZeroJudge-r489"><a href="#第二題-航空拍照圖-ZeroJudge-r489" class="headerlink" title="第二題 航空拍照圖 (ZeroJudge r489.)"></a>第二題 航空拍照圖 (ZeroJudge r489.)</h2><h3 id="題目-1"><a href="#題目-1" class="headerlink" title="題目"></a><a href="https://zerojudge.tw/ShowProblem?problemid=r489">題目</a></h3><div class="alert-block alert-success">給定兩張灰階航空照片 $A$ 和 $B$，尺寸均為 $R \times C$。現要比對照片 $A$ 和 $B$ 的相似度，比對時允許將 照片旋轉 $0^\circ, 90^\circ, 180^\circ$ 或 $270^\circ$ 度。如果兩張照片的原始尺寸不符，則相似度視為 $0$。在尺寸相同（設為 $R \times C$）時，相似度的定義是對應位置像素值相同個數 $S$ 佔總像素數 $R \times C$ 的百分比，計算公式為 $\lfloor \frac{S}{R \times C} \times 100 \rfloor$。輸出這兩張照片經過旋轉之後最高的相似度百分比，結果必須<strong>無條件捨去。</strong></div><h3 id="輸入-輸出說明-1"><a href="#輸入-輸出說明-1" class="headerlink" title="輸入 &#x2F; 輸出說明"></a>輸入 &#x2F; 輸出說明</h3><table><thead><tr><th align="left"><strong>輸入說明</strong></th><th align="left"><strong>輸出說明</strong></th></tr></thead><tbody><tr><td align="left">第一行有兩個數字 $R$ 和 $C$ $(1 \le R, C \le 200)$，代表照片的行數和列數。接下來是第一張圖 $A$，有 $R$ 行，每行有 $C$ 個數字。最後是第二張圖 $B$，有 $R$ 行，每行有 $C$ 個數字。數值介於 $0$ 到 $255$。<br>(60 分): $R &#x3D; 1$<br>(40 分): 無限制</td><td align="left">輸出兩張照片的相似度百分比。</td></tr></tbody></table><h3 id="解題思路-1"><a href="#解題思路-1" class="headerlink" title="解題思路"></a>解題思路</h3><div class="alert-block alert-warning">這題可以轉兩張圖，A 跟 B 都可以轉，但其實只需要轉一個就好，我是 A 不轉、B 轉因為假設 A 轉 90 度、B 不轉就等於 A 不轉、B 轉 270 度；A 轉 270 度、B 轉 90 度就等於 A 不轉、B 轉 180 度等等。所以 A 不需要轉就可以比對全部的組合。那這題的問題就是 B 轉 90 度、180 度、270 度要怎麼表示。我用圖片表示：<div style="display: flex; gap: 10px; margin: 10px 0;">    <img src="圖片1.jpg" alt="圖片1" style="width: 100%; border-radius: 4px; object-fit: contain;">    <img src="圖片2.jpg" alt="圖片2" style="width: 100%; border-radius: 4px; object-fit: contain;"><img src="圖片3.jpg" alt="圖片3" style="width: 100%; border-radius: 4px; object-fit: contain;"></div>我們先看轉 90 度、270 度，因為這兩個必須在 R 等於 C 的時候才可以對比，因此比較容易看。我們都看第一列 (綠色標示的地方)，可以觀察到：1. 轉 90 度在原本的列 i = 0 的位置，轉了之後的 B 是行固定在 4，也就是新的行對應的是受舊的列控制，也就是 B[?][R-i-1]。接著看原本的列 i = 0 的時候，原本的行 j 改變的時候，新的列跟著變，從 j = 0 對應到新的 0、j = 1 對應到新的 1等等，結合剛剛得到的 B[?][R-i-1]，轉 90 度就是 B[j][R-i-1]。2. 轉 270 度其實這也可以看成另一邊的轉 90 度。在原本的列 i = 0 的位置，轉了之後的 B 是行固定在 0，一樣的道理，是新的行對應的是受舊的列控制，也就是 B[?][i]。接著看原本的列 i = 0 的時候，原本的行 j 改變的時候，新的列跟著變，從 j = 0 對應到新的 4、j = 1 對應到新的 3等等，可以看出是 R-j-1，結合剛剛得到的 B[?][i]，轉 270 度就是 B[R-j-1][i]。接著我們看 B 轉 180 度的情況，因為這兩個 R 不一定等於 C，所以要小心，上面轉 90 度、270 度的時候，R 寫成 C 是一樣的，但這邊不一樣。<div style="display: flex; gap: 10px; margin: 10px 0;">    <img src="圖片4.jpg" alt="圖片4" style="width: 100%; border-radius: 4px; object-fit: contain;">    <img src="圖片5.jpg" alt="圖片5" style="width: 100%; border-radius: 4px; object-fit: contain;"></div>這邊一樣看第一列 (綠色標示的地方)，可以觀察到：在原本的列 i = 0 的位置，轉了之後的 B 是列固定在 3，也就是新的列對應的是受舊的列控制，也就是 B[R-i-1][?]。接著看原本的列 i = 0 的時候，原本的行 j 改變的時候，新的行跟著變，從 j = 0 對應到新的 4、j = 1 對應到新的 3 等等，結合剛剛得到的 B[R-i-1][?]，轉 180 度就是 B[R-i-1][C-j-1]。<br><strong><註解></strong> 其實你們也可以用另一個陣列存，然後一直轉 90 度去比，這樣做的優點是不用考慮三種情況，比較不容易錯，也比較容易 debug，留給你們練習</div><h3 id="範例程式碼-1"><a href="#範例程式碼-1" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">int</span> R, C;</span><br><span class="line"><span class="type">int</span> s[<span class="number">4</span>]=&#123;&#125;, Max;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; R &gt;&gt; C;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[R][C], B[R][C];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;R;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;C;j++) &#123;</span><br><span class="line">cin &gt;&gt; A[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;R;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;C;j++) &#123;</span><br><span class="line">cin &gt;&gt; B[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;R;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;C;j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i][j] == B[i][j]) &#123;  <span class="comment">// 旋轉 0 度 </span></span><br><span class="line">s[<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (A[i][j] == B[R-i<span class="number">-1</span>][C-j<span class="number">-1</span>]) &#123;  <span class="comment">// 旋轉 180 度 </span></span><br><span class="line">s[<span class="number">2</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (R == C) &#123;  <span class="comment">// 必須 R == C (正方形)，旋轉 90 度與 270 度才能比 </span></span><br><span class="line"><span class="keyword">if</span> (A[i][j] == B[j][R-i<span class="number">-1</span>]) &#123;  <span class="comment">// 旋轉 90 度 </span></span><br><span class="line">s[<span class="number">1</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (A[i][j] == B[R-j<span class="number">-1</span>][i]) &#123;  <span class="comment">// 旋轉 270 度 </span></span><br><span class="line">s[<span class="number">3</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Max = s[<span class="number">0</span>];  <span class="comment">// 存 S 的最大值 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;  <span class="comment">// 計算 S 的最大值 </span></span><br><span class="line"><span class="keyword">if</span> (s[i] &gt; Max) &#123;</span><br><span class="line">Max = s[i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// cout &lt;&lt; s[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (Max * <span class="number">100</span>) / (R * C)  &lt;&lt; <span class="string">&quot;%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="運行結果-1"><a href="#運行結果-1" class="headerlink" title="運行結果"></a>運行結果</h3><p><font color="#00BB00"><strong>AC</strong></font> (3ms, 632KB)</p><h2 id="第三題-商品包裝地-ZeroJudge-r490"><a href="#第三題-商品包裝地-ZeroJudge-r490" class="headerlink" title="第三題 商品包裝地 (ZeroJudge r490.)"></a>第三題 商品包裝地 (ZeroJudge r490.)</h2><h3 id="題目-2"><a href="#題目-2" class="headerlink" title="題目"></a><a href="https://zerojudge.tw/ShowProblem?problemid=r490">題目</a></h3><div class="alert-block alert-success">給定 $N$ 筆長度為 13 的商品條碼。條碼前 3 碼為產地，第 13 碼為檢驗碼 $C$。令 $S_{odd}$​ 為條碼前 12 位中奇數位（位置 1,3,…,11）的總和。令 $S_{even}$​ 為條碼前 12 位中偶數位（位置 2,4,…,12）的總和。若一個條碼滿足以下條件則視為合法：$(S_{odd}+3 \times S_{even}) \bmod 10 + C = 0$ 或 $10$請統計所有<strong>合法條碼</strong>中最多的產地（前 $3$ 碼）及其對應數量。保證答案唯一，且至少有一組有效條碼。</div><h3 id="輸入-輸出說明-2"><a href="#輸入-輸出說明-2" class="headerlink" title="輸入 &#x2F; 輸出說明"></a>輸入 &#x2F; 輸出說明</h3><table><thead><tr><th align="left"><strong>輸入說明</strong></th><th align="left"><strong>輸出說明</strong></th></tr></thead><tbody><tr><td align="left">輸入的第一行是一個整數 $N$ ( $1 \le N \le 100$ )。 接下來的 $N$ 行，每行是一個長度為 $13$ 的商品條碼字串。</td><td align="left">輸出包含一行，為出現次數最多合法條碼的產地（ $3$ 位字串）和其對應的數量，兩者之間以一個空格隔開。</td></tr></tbody></table><h3 id="解題思路-2"><a href="#解題思路-2" class="headerlink" title="解題思路"></a>解題思路</h3><div class="alert-block alert-warning">老實說我覺得這題好像比上一題簡單一點。這題其實只需要用陣列就可以了，不需要用 map，因為產地代碼只有 3 位，這樣就是 000 ~ 999，那我就設一個 num[1000] 去存就可以了。我們就用 for(j=0;j<12;j=j+2) 迴圈去跑條碼 s 索引是 0 ~ 11 (第 1 位 ~ 第 12 位) 的狀況，那 j = j + 2 代表他是 j = 0, 2, 4, 6, 8, 10，我們每次就把 s[j] 加到 s_odd、s[j+1] 加到 s_even 就可以了 (這邊要注意，索引 0 是第 1 位，所以 j 每次加 2 都是在奇數位喔)。最後記得判斷 < 10 的時候要補 00，10 ~ 99 之間的時候要補 0。</div><h3 id="範例程式碼-2"><a href="#範例程式碼-2" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j, N, s_odd, s_even, C;</span><br><span class="line"><span class="type">int</span> check, place, Max = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num[<span class="number">1000</span>]=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">s_odd = <span class="number">0</span>;</span><br><span class="line">s_even = <span class="number">0</span>;</span><br><span class="line">C = s[<span class="number">12</span>] - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 第 13 碼轉成 int 存在 C</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">12</span>;j=j<span class="number">+2</span>) &#123;  <span class="comment">// 一次 + 2 (一次會處理奇數+偶數) </span></span><br><span class="line">s_odd += s[j] - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 奇數位</span></span><br><span class="line">s_even += s[j<span class="number">+1</span>] - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 偶數位 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check = (s_odd + <span class="number">3</span> * s_even) % <span class="number">10</span> + C;  <span class="comment">// 合法條件的公式計算 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (check == <span class="number">0</span> || check == <span class="number">10</span>) &#123;  <span class="comment">// 產地合法</span></span><br><span class="line">place = (s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>) * <span class="number">100</span> + (s[<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s[<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>);  <span class="comment">// 產地轉乘 int</span></span><br><span class="line"></span><br><span class="line">num[place]++;  <span class="comment">// 該產地出現數量 + 1 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">1000</span>;i++) &#123;  <span class="comment">// 找出出現次數最多的產地 </span></span><br><span class="line"><span class="keyword">if</span> (num[i] &gt; num[Max]) &#123;</span><br><span class="line">Max = i; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Max &lt; <span class="number">10</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;00&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Max &lt; <span class="number">100</span>)  <span class="comment">// 10 &lt; Max &lt; 100</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; Max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num[Max];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="運行結果-2"><a href="#運行結果-2" class="headerlink" title="運行結果"></a>運行結果</h3><p><font color="#00BB00"><strong>AC</strong></font> (1ms, 332KB)</p><div class="alert-block alert-danger"><strong>查看更多資訊請至：</strong><a href="https://www.tseng-school.com/">https://www.tseng-school.com/</a> </div>]]></content>
    
    
    <summary type="html">此筆記為APCS 2025年10月實作題考試的題目詳解。每一題的題解都包含解題思路、C++範例程式碼。</summary>
    
    
    
    <category term="APCS" scheme="https://www.tseng-school.com/categories/APCS/"/>
    
    
    <category term="C++" scheme="https://www.tseng-school.com/tags/C/"/>
    
    <category term="APCS" scheme="https://www.tseng-school.com/tags/APCS/"/>
    
    <category term="ZeroJudge" scheme="https://www.tseng-school.com/tags/ZeroJudge/"/>
    
  </entry>
  
</feed>
